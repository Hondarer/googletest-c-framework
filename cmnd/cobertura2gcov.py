#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
cobertura2gcov.py - Cobertura XML を gcov 形式に変換するスクリプト

使用方法:
    python cobertura2gcov.py <cobertura.xml> <output_dir>

引数:
    cobertura.xml  - 入力となる Cobertura 形式の XML ファイル
    output_dir     - gcov ファイルの出力先ディレクトリ

出力:
    各ソースファイルに対応する .gcov ファイルを output_dir に生成する。
    ファイル名は元のソースファイル名に .gcov を付加したもの。
"""

import sys
import os
import re
import xml.etree.ElementTree as ET
from pathlib import Path


def parse_condition_coverage(coverage_str):
    """
    condition-coverage 文字列からカバー数と総数を抽出する。

    Args:
        coverage_str: "50% (1/2)" 形式の文字列

    Returns:
        (covered, valid) のタプル、パース失敗時は (0, 0)
    """
    if not coverage_str:
        return (0, 0)
    match = re.search(r'\((\d+)/(\d+)\)', coverage_str)
    if match:
        return (int(match.group(1)), int(match.group(2)))
    return (0, 0)


def parse_cobertura(xml_path):
    """
    Cobertura XML をパースし、ソースファイルごとのカバレッジ情報を抽出する。

    Args:
        xml_path: Cobertura XML ファイルのパス

    Returns:
        dict: {ソースファイルパス: {'lines': {行番号: ヒット数}, 'branches': {行番号: (covered, valid)}}} の辞書
    """
    tree = ET.parse(xml_path)
    root = tree.getroot()

    # sources 要素からベースパスを取得
    sources = root.findall('.//source')
    base_path = sources[0].text if sources else ''

    coverage_data = {}

    for package in root.findall('.//package'):
        for cls in package.findall('.//class'):
            filename = cls.get('filename')
            # source + filename でフルパスを構成
            if base_path:
                # Windows のドライブレター (例: "D:") の場合、
                # os.path.join は "D:" + "path" を "D:path" にしてしまうため
                # 明示的にパス区切りを追加
                if len(base_path) == 2 and base_path[1] == ':':
                    full_path = base_path + os.sep + filename
                else:
                    full_path = os.path.join(base_path, filename)
            else:
                full_path = filename

            # 行カバレッジと分岐カバレッジを抽出
            lines = {}
            branches = {}
            for line in cls.findall('.//line'):
                line_num = int(line.get('number'))
                hits = int(line.get('hits'))
                lines[line_num] = hits

                # 分岐カバレッジを抽出
                if line.get('branch') == 'true':
                    cov = parse_condition_coverage(line.get('condition-coverage'))
                    if cov[1] > 0:
                        branches[line_num] = cov

            coverage_data[full_path] = {'lines': lines, 'branches': branches}

    return coverage_data


def read_source_file(source_path):
    """
    ソースファイルを読み込む。

    Args:
        source_path: ソースファイルのパス

    Returns:
        list: ソースコードの各行のリスト。読み込めない場合は None。
    """
    try:
        # 複数のエンコーディングを試行
        for encoding in ['utf-8', 'shift_jis', 'cp932', 'latin-1']:
            try:
                with open(source_path, 'r', encoding=encoding) as f:
                    return f.readlines()
            except UnicodeDecodeError:
                continue
        return None
    except FileNotFoundError:
        return None
    except Exception:
        return None


def generate_gcov(source_path, coverage_info, output_dir):
    """
    gcov 形式のファイルを生成する。

    gcov 形式:
        実行回数:行番号:ソースコード
        - 実行回数が 0 の場合は "#####"
        - 実行対象外の行は "-"
        - 分岐情報: branch X taken Y% または branch X never executed

    Args:
        source_path: ソースファイルのパス
        coverage_info: {'lines': {行番号: ヒット数}, 'branches': {行番号: (covered, valid)}} の辞書
        output_dir: 出力ディレクトリ
    """
    line_coverage = coverage_info['lines']
    branch_coverage = coverage_info.get('branches', {})
    source_lines = read_source_file(source_path)

    # 出力ファイル名を決定
    source_name = os.path.basename(source_path)
    gcov_filename = f"{source_name}.gcov"
    output_path = os.path.join(output_dir, gcov_filename)

    with open(output_path, 'w', encoding='utf-8') as f:
        # gcov ヘッダー行
        f.write(f"        -:    0:Source:{source_path}\n")
        f.write(f"        -:    0:Graph:generated by cobertura2gcov\n")
        f.write(f"        -:    0:Data:cobertura.xml\n")

        if source_lines is None:
            # ソースファイルが読めない場合、カバレッジ情報のみ出力
            f.write(f"        -:    0:Note:Source file not found\n")
            for line_num in sorted(line_coverage.keys()):
                hits = line_coverage[line_num]
                if hits > 0:
                    exec_count = f"{hits:9d}"
                else:
                    exec_count = "    #####"
                f.write(f"{exec_count}:{line_num:5d}:\n")
        else:
            # ソースコードとともに出力
            for i, line_content in enumerate(source_lines, start=1):
                line_content = line_content.rstrip('\n\r')

                if i in line_coverage:
                    hits = line_coverage[i]
                    if hits > 0:
                        exec_count = f"{hits:9d}"
                    else:
                        exec_count = "    #####"
                else:
                    # カバレッジ対象外の行
                    exec_count = "        -"

                f.write(f"{exec_count}:{i:5d}:{line_content}\n")

    return output_path


def main():
    if len(sys.argv) != 3:
        print("Usage: python cobertura2gcov.py <cobertura.xml> <output_dir>",
              file=sys.stderr)
        sys.exit(1)

    xml_path = sys.argv[1]
    output_dir = sys.argv[2]

    # 入力ファイルの存在確認
    if not os.path.exists(xml_path):
        print(f"Error: Input file not found: {xml_path}", file=sys.stderr)
        sys.exit(1)

    # 出力ディレクトリの作成
    os.makedirs(output_dir, exist_ok=True)

    # Cobertura XML をパース
    try:
        coverage_data = parse_cobertura(xml_path)
    except ET.ParseError as e:
        print(f"Error: Failed to parse XML: {e}", file=sys.stderr)
        sys.exit(1)

    if not coverage_data:
        print("Warning: No coverage data found", file=sys.stderr)
        sys.exit(0)

    # 各ソースファイルの gcov を生成
    generated_files = []
    for source_path, coverage_info in coverage_data.items():
        output_path = generate_gcov(source_path, coverage_info, output_dir)
        generated_files.append(output_path)
        print(f"Generated: {output_path}")

    #print(f"\nGenerated {len(generated_files)} gcov file(s)")


if __name__ == '__main__':
    main()
